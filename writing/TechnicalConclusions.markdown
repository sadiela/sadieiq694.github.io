#Technical Conclusions

##Results Summary

During week one my team completed both goals; we became comfortable with ROS, Linux, and Python and we wrote a functional wall following node. Our fastest time achieved during the final challenge was 8.645 seconds and we finished in sixth place.

The second week was the least successful, not just for me and my team but for most teams in the program. Only two teams had successful runs in the final challenge. However all of the students definitely completed the first goal of gaining experience in image processing and blob detection.

I consider week three to be the week that my team was the most successful. Not only did we work cohesively and quickly, we finished the final challenge with 58 points and earned second place.

Although there were some bumps and we were unsuccessful in implementing vision code in either the second technical challenge or the time trials, for the most part week four was a triumph. We placed third in the time trials with a time of 35:33, second in the heat race, and fourth in the grand prix.

##Findings

Of course, this program taught me a lot about ROS, Python, Linux, and many common algorithms used in programming autonomous vehicles.

After participating in this program, I also have a much better understanding and appreciation of the complexity entailed in programming autonomous vehicles. Even the grossly simplified version of the problem companies like Google are trying to solve that students were faced with at Beaver Works Summer Institute was a formidable challenge.

##In the Future

I came away from the program with many lessons that will continue to be relevant for the rest of my academic career and beyond. The first of these lessons was the importance of planning. When a course of action is defined before anything is actually started, the work process goes much more smoothly. The plan may change as new information reveals itself, but having the steps to the goal roughly decided ahead of time cuts down the amount of wasted time and helps with organization. I also learned ways to make debugging much easier. If one adds print statements after conditionals and at the start of functions, locating the source of an error becomes simple. Finally, I learned to reach out for help when I needed. Sometimes another pair of eyes is all that is necessary to turn a broken program into a fully functional program.
